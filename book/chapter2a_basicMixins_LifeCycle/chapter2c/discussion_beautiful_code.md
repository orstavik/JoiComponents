
## Discussion: Can code be ugly and pretty at the same time? 

This is an intriguing question. But, its answer rests on answers on some other fundamental questions.
What is ugly and pretty code? Why can I feel code as either ugly and/or pretty? 
And what does it all mean?

Ok, the last question. That might be a bit of a stretch. And we know the answer already: 42.
But the other questions, what has computer code to do with esthetics? 
Why do I "sense" code as being "ugly" or "nice"? Why's that?

To me, code can be pretty when:
 * its structure is clear and clarifying,
 * it me shows both a problem and a solution I had not seen before, but still recognize,
 * it solves a familiar problem in an unfamiliar way,
 * or an unfamiliar problem using a concept I already know,
 * it teaches me something new, makes a structure or grammatical form or a metaphor familiar,
 * it fits my peculiar stylistic choices, like not using braces in single line if clauses and 
   functions with inverse if-clauses that exits a function instead of wrapping blocks 
   into blocks into blocks, because that is the way I like it.
 * nicely modulated, ohh, that is important, well formed functions and modules and interfaces,
 * aligns nicely in my current editor,
 * etc. etc.
   
Code is ugly when it is:
 * boastful, but without merit,
 * adds complexity unnecessary,
 * obfuscates for reason,
 * verbose,
 * unfamiliar,
 * uses wrong API functions or strategies that might become a problem later, 
   when the platform or use-case slightly changes,
 * it is not mine, and I don't want to add the complexity nor responsibility of others code,
 * it is from an institution or person I don't trust, and I'm not in a trusting mood.
 * etc. etc.
 
My esthetic sense for code is not rational. 
Pretty and ugly is not computed by a single threaded rational, consciousness. 
Rather, it is based on my feelings and my mood at that moment.
My code feeling is based on my personal experience and my style.
It is directed towards my current needs and trends I like.
It is multithreaded. It is analogue. 
It is not linear, it can change dramatically with just a slight adjustment in one of its input parameters.

And I trust it. Partially. As I would trust any other gut feeling.
I believe that ugly code will just give me problems and pain. 
And so too for all other people in the world when I don't get over myself 
and have forgotten that a) we are all different and b) that is ok. 
I feel that pretty code will somehow give me pleasure and sweetness.
And I so hope that others will feel the same about my code.
And I feel at home and with friends when they do.

In my single threaded consciousness I have rationalized that my code instincts has a purpose.
That my sense of beauty and ugliness is given to me by evolution.
My esthetic sense is my minds GPU.
It has been developed to recognize landscapes in which fruits and prey likely would occur.
It has been developed to enable my prior experiences mix with the teachings of elders I partially trust.
If I had seen snakes behind stones that looked like those stones over there, 
those stones over there would echo the ugly face and hide of that last snake.
It also includes the reference to lightbrown that my stupid uncle like so much, but 
that I find ugly myself.

And for me this is the key to understanding that first question. 
Can code be beautiful and ugly at the same time?
The answer is yes. I can look at some code, and 
the landscape of that code can echo a landscape full of *both* berries and snakes.
It needs a closer look. Where might the snakes be? And where can I find those berries? 
And they might be inseparable. The snake is likely coiled up right under the berry bush so 
as to strike out at the next frightened, but hungry mouse that come looking for some sugar.

Code is the same. Sometimes, if you build your bush of berries in a place where 
the snake can't hide in it, all the berries will just be eaten by mice, after some months.
On some rare occasions, due to the environment, to keep the sweetness you must include ugly.
You must do something that immediately strike you and others as wrong, but 
that your gut tells you will be the right choice when you need it later. 
Or at least the best of currently available alternatives. 

And so it is with the punchlines of `setupCallback()`.
Delaying `setupCallback()` in a mixin, might make it look prettier at first. 
But the mice that hide in the mixins will eat the berries of `setupCallback()` 
as soon as you turn your back to it. I feel it.
I feel that this mixin will be combined with another mixin that a) will run some code it shouldn't 
before `setupCallback()` is invoked or b) for some reason should not(!) be delayed in such a manner.
And I feel that when using a mixin, you will discover this problem too late, 
after the harm is done and these mixin mice has eaten all the setup berries.
The punchline snake however will stay where you left it, right there at the surface.
That snake is ugly. Dangerous. But. The way it stays put and both guards the berries and keeps the berry picker 
on his toes, now that is beautiful. The environment around setup of custom elements 
is full of pests, and the punchline snake is the one you want.

`setupCallback()` is just `constructor2()`. With makeup on.
Right now, it is actually hard for me to even imagine an uglier name for a method than `constructor2()`.
But what the hell. In the bar that is the `HTMLElement`, ugly is the norm.
And so if it is pretty with make up on, 
one should accept that as the lesser of two evils.
Hey! Miss `Polymer.ready`, miss `DOMContentLoaded` or mrs `onlyOnceInConnectedCallback()` are 
also just `constructor2()`, but with even more makeup and less honesty about it.
In this bar, inner beauty and sparse makeup are the deciding factors. 

You might still find the `setupCallback()` punchlines hideous. 
They might scare you, and based on your experience and taste and sense of code, 
you might choose to plant your bush of setup berries somewhere else.
I respect that. Although with a little resentment, as this is, after all, esthetics we are talking about.
I cannot help but feel that you will spread setup berries around the environment and 
so contribute to spreading mixin mice or framework flees and other bad viral practices and trends 
on our shared planet. 
I, personally, will plant my setup berries next to the punchline snake.
I will spread punchline snakes.
I fear the mixin mice and frameworks flies more. 
I know that dealt with correctly, the snake is less harmful to men than mice.

My last comment is this.
Bad code will steals time like nothing else. 
It can break products and business processes worth millions upon millions.
To a business and job security, bad code is as dangerous as floods and hurricanes.
And it is the programmer that both accidentally makes it and tames it and defends it.
Code can frustrate you like nothing else.
And if you combine bad code with other people, 
especially other people with no interest nor sense of responsibility for that code,
you are asking for trouble.

With experience, programmers will learn to associate the feeling of pain and frustration with certain type of code.
And they will learn to recognize sweetness and joy and flow and control in it.
A well developed sense of code is what separates the novice from the master, the good from the bad.
It is not smartness that will make you a good programmer.
To me, smartness is more likely to produce arrogant, brittle code, its beauty faiding fast.
It is not primarily the ability to through concentration and short term memory 
build and maintain large mental constructs.
Although useful, when such code needs to be updated, the programmer himself or others must do the same.
That is truly annoying, why couldn't that smartass have modularized his code a bit better in the first place?!
My point is this. 
The sense of code programmers develop is not quaint, not an irrelevant relic from the caveman.
It is the most important part of the programmers mind, his most important tool*bag*.
It is why *humans* are the programmers, and not the machines.
That is why programming is an artform, not a science.
