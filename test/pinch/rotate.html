<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    function getParameterByName(name, url) {
      if (!url) url = window.location.href;
      name = name.replace(/[\[\]]/g, "\\$&");
      var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
      if (!results) return null;
      if (!results[2]) return '';
      return decodeURIComponent(results[2].replace(/\+/g, " "));
    }
    var eAOc = parseInt(getParameterByName("eventAndOrCallback") || 0);
  </script>
  <meta charset="UTF-8">
  <title>Title</title>
  <style type="text/css" rel="stylesheet">

    rotate-block {
      display: inline-block;
      position: relative;
      width: 150px;
      height: 150px;
      margin: 20px;
      border: 4px solid blue;
      border-radius:  0 50% 50% 50%;
    }

  </style>
  <script src="https://hammerjs.github.io/dist/hammer.js"></script>
  <script src="//cdn.rawgit.com/hammerjs/touchemulator/0.0.2/touch-emulator.js"></script>
  <script> TouchEmulator(); </script>
</head>
<body>
<rotate-block>Callback()</rotate-block>
<script type="module">
  import {PinchGesture} from '../../src/gestures/Pinch.js';

  class RotateBlock extends PinchGesture(HTMLElement) {

    static get dragFlingEventOrCallback() {
      return eAOc;
    }

    constructor() {
      super();
      this._pinchstartListener = e => this.pinchstartEvent(e.detail);
      this._pinchListener = e => this.pinchEvent(e.detail);
    }

    connectedCallback(){
      super.connectedCallback();
      this.addEventListener("pinchstart", this._pinchstartListener);
      this.addEventListener("pinch", this._pinchListener);
    }

    disconnectedCallback(){
      super.disconnectedCallback();
      this.removeEventListener("pinchstart", this._pinchstartListener);
      this.removeEventListener("pinch", this._pinchListener);
    }

    pinchstartEvent(pinchDetail) {
      const lastRotate = this.style.transform ? parseFloat(this.style.transform.substring(7)) : 0;
      this._startAngleEvent = lastRotate + pinchDetail.angle;
    }
    pinchEvent(pinchDetail) {
      console.log(pinchDetail.angle);
      this.innerText = `rotate(${this._startAngleEvent - pinchDetail.angle}deg)`;
    }

    pinchstartCallback(pinchDetail) {
      const lastRotate = this.style.transform ? parseFloat(this.style.transform.substring(7)) : 0;
      this._startAngle = lastRotate + pinchDetail.angle;
    }
    pinchCallback(pinchDetail) {
      this.style.transform = `rotate(${this._startAngle - pinchDetail.angle}deg)`;
//      this.dispatchEvent(new CustomEvent("pinch", detail));
      //todo remove the staticSetting for eventAndOrCallback, replace with just a description of how to dispatch events from callbacks?
      //todo That is very simple, and it costs very little.. yes , it costs very little.
      //todo the problem is that sometimes, we want only the events to be thrown. That would make our code simpler.
      //todo so, in that case, we might want a staticSetting that throws events too.. yes. so the static setting is only
      //todo throwEvents() return [list of event names]?? or will that be very heavy.. hm, that will be a little heavy. And complex
      //todo the only thing I would like to save is the throwing of events from the move itself.
      //todo no, I throw all events, or I throw none. I always do callbacks.
      //todo that is it.
    }
  }

  customElements.define("rotate-block", RotateBlock);

</script>
</body>
</html>
